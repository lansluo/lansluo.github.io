<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阿里云OSS图床搭建与配置</title>
      <link href="/posts/26396.html"/>
      <url>/posts/26396.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>刚开始使用Typora编写markdown文件的时候经常会遇到图片丢失问题。这个问题其实挺烦的😡，一直苦恼。直到**<code>图床</code>**的出现，才彻底解决了这个问题。</p><p>我们先看一下问题现象，如下</p><p>这是本地的markdown文件，可以正常显示图片，一个性感的2B小姐姐哦😄。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251113153730276.png" alt="image-20251113153728775"></p><p>这是博客文档移植到Hexo博客上显示的图片。哦，天呐！！！我的2B小姐姐呢？怎么没了？😭</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251113153937845.png" alt="image-20251113153936289"></p><h2 id="问题根源与解决方案">问题根源与解决方案</h2><p>图片丢失的核心原因是：使用Markdown编写时的插入的图片属于引用资源，不属于文件本身，图片存储在本地，当文档迁移时，原始路径被破坏，图片自然无法加载。</p><p>根据以上原因，只要资源的位置发生改变，那么就会出现图片找不到的情况，放到Hexo博客上图片自然就丢失了啦。既然如此，那么我们解决思路自然就是适配正确的图片引用路径。通过这种思路就衍生出了两套解决方方案:</p><ol><li><strong>图床方案（推荐）</strong>：将图片上传至云端存储，通过固定 URL 引用</li><li><strong>本地路径适配</strong>：手动同步图片到目标平台的资源目录并修改路径</li></ol><p>这里极力推荐使用图床，第二种办法其实就是移动资源到主体的资源目录下，然后用资源目录的图片路径替换原路径，就可以显示图片了。这个可以自己去实验，挺麻烦的，一两个图片资源还好，多了就搞不过来了，这里我就不做演示了，反正也是一种解决办法，就是比较土啦。</p><p>因此，本文重点介绍<strong>图床方案</strong>—— 通过云端存储实现图片的跨平台稳定访问。</p><h2 id="什么是图床">什么是图床</h2><p><code>&quot;图床&quot;</code>是一个网络术语，它指的是一种用于存储和托管图片的在线服务。通常情况下，图床允许用户上传图片文件，并提供一个链接或者嵌入代码，使得用户可以在网页或者论坛等地方方便地分享和展示这些图片。</p><p>上面解释的很明白了，&quot;图床&quot;其实就是一个文件存储服务，我们一般称之为<strong>对象存储服务 Object Storage Service</strong>，简称OSS。</p><p>这里需要说明的是，只有OSS是不够的，OSS只是提供了图床的在线存储和托管图片的服务，要想完整丝滑流畅的使用图床能力，还需要<code>PicGo</code>和<code>Typore</code>这两个软件作为图床的客户端，并进行一些配置。</p><p>要实现 Markdown 写作时的 “无缝传图”，需三个核心工具配合：</p><ul><li><strong>阿里云 OSS</strong>：提供云端存储能力（图床的 “仓库”）</li><li><strong>PicGo</strong>：自动化上传工具（连接本地与云端的 “桥梁”）</li><li><strong>Typora</strong>：编辑器集成（触发上传的 “入口”）</li></ul><p>我简单画了一个流程图。😄如下：</p><pre><code class="highlight mermaid">flowchart LR;  Typora----&gt;|图片|PicGo;  PicGo----&gt;|图片|阿里云OSS;  阿里云OSS----&gt;|url|PicGo;   PicGo----&gt;|url|Typora;</code></pre><blockquote><p>简单来说就是在 Typora 插入图片时，PicGo 会自动将图片上传到阿里云 OSS，再把云端 URL 返回给 Typora，最终文档中保存的是永久有效的云端链接。</p></blockquote><h2 id="图床搭建">图床搭建</h2><h3 id="阿里云OSS配置">阿里云OSS配置</h3><p>我选择使用阿里云OSS，OSS服务的提供商有很多，阿里、腾讯、华为等等都可以，而且非常简单配置，当然如果你不嫌麻烦或者想要挑战一下折腾难度，你也可以自己搭建。既然选择阿里云OSS，那就得先有一个阿里云账号，这个可以自己先行注册，比较简单，这里不再赘述。</p><h4 id="进入控制台">进入控制台</h4><p>我们进入<a href="https://www.aliyun.com/">阿里云官网</a>，点击控制台</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20251113201058748.png" alt="image-20251113201058748"></p><p>控制台分为旧版和新版，OSS的入口位置不一样，各自找一下就可以了。</p><blockquote><p>旧版位置</p></blockquote><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20251113200505185.png" alt="image-20251113200505185"></p><blockquote><p>新版位置</p></blockquote><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20251113200440745.png" alt="image-20251113200440745"></p><h4 id="创建-Bucket">创建 Bucket</h4><blockquote><p>这里需要引入OSS的一个核心概念就是<strong>Bucket（存储桶）</strong>。</p></blockquote><p><strong>Bucket</strong> 又被称为<strong>存储桶</strong>，它是在OSS中用于组织和管理在对象存储服务中存储的数据（即对象）的逻辑单位。可以将 它理解为一个“文件夹”，里面可以存放各种数据（图片，文件…）。我们在使用OSS存放图片时就需要建立一个 <strong>Bucket</strong>。不然我们在OSS中的资源将会变得很乱，刚开始还好，如果时间一久，很多资源管理起来非常麻烦。 <strong>Bucket</strong> 就能很好打帮我们管理相关资源</p><p>点击进入OSS控制台管理页面，选择 <strong>对象存储 OSS</strong>，然后点击 <strong>创建 Bucket</strong>，按提示完成创建，并点击 <code>完成创建</code>。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/c89d5e2fca0f5d4288caaf8cd9d7ea83.png" alt="image-20250115175716434"></p><p>我们在创建 Bucket 时名称不能包含大写字母。存储类型选择 <strong>标准存储</strong>，权限设置为 <strong>公共读</strong>。</p><blockquote><p>注意：这里我引用了一位大佬的图片。他的截图比我截的好，我也是照着它的教程做的。</p></blockquote><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/950ca4cdefd4af8318975f020b052f11.png" alt="image-20250115181423142"></p><h4 id="修改读写权限">修改读写权限</h4><p>进入创建的 Bucket 后，选择 <strong>概览</strong>，找到 <strong>读写权限</strong> 选项，设置为 <strong>公共读</strong>。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/fccec4a3b1477d78ef09ab0544902c79.png" alt="image-20250115180813593"></p><h4 id="获取访问域名">获取访问域名</h4><p>在 <strong>概览</strong> 页面下，找到 <strong>访问端口</strong>，复制访问域名（注意：不要复制 <code>.aliyuncs.com</code> 部分）。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/926141a8837dfd9691f50b0658136172.png" alt="image-20250115181550608"></p><h4 id="创建-AccessKey">创建 AccessKey</h4><p>点击右上角头像，选择 <strong>AccessKey</strong>，然后创建一个新的 AccessKey，并记录下 <strong>AccessKeyId</strong> 和 <strong>AccessKeySecret</strong>。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/9370df3d3860577221f9c462dfee2983.png" alt="image-20250115181755481"></p><p>点击继续使用云账号</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/541260ee811afd99834bae5da9b479ea.png" alt="image-20250115181852493"></p><p>点击创建AccessKey</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/a4012ead61cd8a177dc54c65d61dc580.png" alt="image-20250115181930007"></p><p>需要注意的是，阿里OSS并不免费，但是收费也还能够接受。分为<strong>按量付费</strong>和<strong>购买资源包</strong>两种计费模式。</p><ol><li><strong>按量付费</strong>：是默认模式，后付费方式，先使用、后付费，按照各计费项的实际用量结算费用。</li><li><strong>购买资源包</strong>：预付费方式，先预付、后使用，针对部分常用计费项（例如存储费用、流量费用）支持专用的资源包</li></ol><p>我没搞那么复杂了，直接选择用按量付费，我只在账号里面充了10源，不够再说吧。只要服务不停就行了😄。</p><h3 id="PicGo配置">PicGo配置</h3><h4 id="PicGo-简介">PicGo 简介</h4><p>PicGo 是一款开源的图床管理工具，旨在简化图片上传过程，支持多种图床平台，包括阿里云 OSS、GitHub、七牛云等。PicGo 提供了图像上传、URL 复制、自动命名等功能，能够大幅提升图像管理效率，尤其适合程序员和博主等需要频繁插入图片的用户。</p><p>这是<a href="https://github.com/Molunerfinn/PicGo/releases/">下载地址</a>。直接安装就可以。PicGo需要Node.js，不然会安装失败，请先保证你的环境中有Node.js。</p><h4 id="配置图床信息">配置图床信息</h4><p>启动 PicGo 后，选择 <strong>图床设置</strong> -&gt; <strong>阿里云 OSS</strong>，将我们之前配置<strong>阿里云OSS</strong>得到的相关信息 AccessKey、Bucket 名称和存储区域，填写到对应位置中，点击确定并设置为默认图床。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/585b2aa403323a62e422cfbdc6b9c377.png" alt="image-20250115192935673"></p><h4 id="配置时间戳命名与-URL-自动复制">配置时间戳命名与 URL 自动复制</h4><blockquote><p>为了避免上传文件时产生冲突，造成文件覆盖和丢失，我们这里还要配置文件命名的规则</p></blockquote><p>进入 <strong>PicGo 设置</strong>，启用<strong>时间戳命名</strong>和上传后自动复制图片 URL 的功能。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/6765b0aeb2347096646a17f98b18c744.png" alt="image-20250115193310679"></p><h3 id="Typora配置">Typora配置</h3><h4 id="配置图像上传">配置图像上传</h4><p>打开 Typora，选择 <strong>文件</strong> -&gt; <strong>偏好设置</strong> -&gt; <strong>图像</strong>，选择 <strong>上传图片</strong>，并在 <strong>上传服务</strong> 选择 <strong>PicGo (app)</strong>。</p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/12ea6a6887fd0c1a5809b491822e26c0.png" alt="image-20250115194135152" /><p>设置插入图像为上传图片</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/b0e199f0b7a4d79140dbde5aab62db86.png" alt="image-20250115194531897"></p><p>选中图片后，右键选择 <strong>格式</strong> -&gt; <strong>HTML 格式</strong>，将图片以 <code>HTML</code> 形式插入</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/d806926cdda698252cc20ce9ce3220b4.png" alt="image-20250115200611010"></p><h2 id="小结">小结</h2><p>通过配置阿里云 OSS（存储）、PicGo（上传）和 Typora（编辑），我们搭建了一套高效的 Markdown 图床方案。从此，在 Typora 中插入的图片会自动上传至云端，文档迁移时再也不用担心图片丢失，极大提升了写作与发布效率。</p><h2 id="附：Typora-1-9-5-版本说明">附：Typora 1.9.5 版本说明</h2><p>低版本 Typora 不支持图床配置，需使用 1.9.5 及以上版本。该版本目前需订阅使用，若需历史版本及相关说明，可关注微信公众号，回复 “Typora” 获取链接。谢谢关注！！！！</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/qrcode_wechat.jpg" alt="qrcode_wechat"></p><p>参考来源: <a href="https://blog.csdn.net/qq_51210361/article/details/145210585">https://blog.csdn.net/qq_51210361/article/details/145210585</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> OSS </tag>
            
            <tag> PicGo </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建装修日记（一）</title>
      <link href="/posts/55708.html"/>
      <url>/posts/55708.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要搭建个人博客">为什么要搭建个人博客</h3><p>首先肯定是我感到无聊和空虚啦，空闲之余，就找点有意义的事情做做，让自己充实起来，我很喜欢自己充实起来的感觉，非常👍和😄。写博文就是我的一次尝试（至于能坚持多久，其实我也没底，哈哈🤭）。</p><p>其次是偶然在网上看到了 Mofan 的博客，发现他搭建的个人博客特别棒👍，很符合我的审美😍（当然他的文章内容也非常好，干货满满，强烈推荐，这是他的<a href="https://mofan212.github.io/">博客链接</a>）。当我读完他的《博客搭建与维护》时，便产生了自己也搭建一个博客，偶尔在上面写写一些东西的想法。</p><h3 id="如何搭建个人博客">如何搭建个人博客</h3><p>Mofan 在《博客搭建与维护》中提到，他的博客是用 Hexo 框架搭建的，并用了 hexo-theme-butterfly 主题美化。于是我开始学习 Hexo 相关知识，着手搭建自己的博客。用 Hexo 框架搭建博客需要 Node.js 和 Git，如果你的电脑已经安装了这两个工具，就可以直接开始了。下面我会讲讲 Node.js 的安装与配置，Git 就不多说了 —— 作为老牌版本控制工具，大部分开发者应该都装了。如果没装，网上也有很多教程可以参考。</p><p>好了，让我们开始愉快的博客搭建之旅吧😄！</p><h4 id="重新安装Node-js">重新安装Node.js</h4><blockquote><p>下载 Node.js</p></blockquote><p>作为 Java 开发者，我电脑里原本没有 Node.js 也很正常 —— 当然，这是开玩笑的😊！。我重新安装 Node.js 是因为电脑里的版本太老了，而且平时不常用，一启动就出各种问题，索性装个新版本。</p><p>我用的Node.js版本为v22.20.0。目前来看这个版本是长期维护的版本，比较稳定。这里不建议下载过高版本，指不定会出什么问题。可能会出现兼容问题。我之前试过最新的 v25.1.0，就遇到了不少乱七八糟的问题，最后还是换回了 v22.20.0。可以去<a href="https://nodejs.org/en/download">官网下载</a>。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251105155635762.png" alt=""></p><blockquote><p>安装Node.js</p></blockquote><p>安装过程很简单，一路点击 Next，再点 Install，最后 Finish 就好，So easy😄！</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106100849332.png" alt="在这里插入图片描述"></p><p>中间有一项可以勾选，其他选项勾不勾影响不大，我一般不勾。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106100929577.png" alt="在这里插入图片描述"></p><p>安装完成后，检查一下是否成功，在 CMD 中执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Nodejs版本</span></span><br><span class="line">node -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看npm版本</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251105171734008.png" alt="image-20251105171731395"></p><h4 id="npm-换源">npm 换源</h4><blockquote><p>查询npm源地址</p></blockquote><p>CMD执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前npm源地址</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>我这里已经改过地址了，所以是淘宝镜像地址。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106095014504.png" alt="image-20251106095004893"></p><blockquote><p>配置npm源</p></blockquote><p>我一直使用的是淘宝镜像源。不过不知道为什么，现在镜像地址换了。以前记得淘宝镜像的地址是这个<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a>。现在换成了<a href="https://registry.npmmirror.com">https://registry.npmmirror.com</a>，不过也无所谓，一样可以用，亲测有效，安心食用😄！</p><p>截止到目前，我整理的可用源地址如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方原始镜像网址</span></span><br><span class="line">npm config set registry https://registry.npmjs.org/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">淘宝镜像</span></span><br><span class="line">npm config set registry https://registry.npmmirror.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阿里云镜像</span></span><br><span class="line">npm config set registry https://npm.aliyun.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">腾讯云镜像</span></span><br><span class="line">npm config set registry https://mirrors.cloud.tencent.com/npm/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">华为云镜像</span></span><br><span class="line">npm config set registry https://mirrors.huaweicloud.com/repository/npm/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网易镜像</span></span><br><span class="line">npm config set registry https://mirrors.163.com/npm/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">中国科学技术大学开源镜像站</span></span><br><span class="line">npm config set registry http://mirrors.ustc.edu.cn/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清华大学开源镜像站</span></span><br><span class="line">npm config set registry https://mirrors.tuna.tsinghua.edu.cn/</span><br></pre></td></tr></table></figure><p>腾讯，华为，阿里的镜像站基本上比较全，不过我个人还是习惯用淘宝镜像，毕竟用了很多年了。</p><p>CMD执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置淘宝镜像源</span></span><br><span class="line">npm config set registry https://registry.npmmirror.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前npm源地址</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20251105211209918.png" alt="image-20251105211209918"></p><blockquote><p>尴尬的cnpm</p></blockquote><p>这里不建议安装cnpm，直接npm换源就可以了，这玩意有BUG的。 之前我使用过程中确实出了很多意想不到的问题，搞了老半天，心力交瘁😩，回过头来还是用了npm。所以大家谨慎选择😯。如果你使用cnpm出现了问题的话，那基本上就是一些环境问题，各种加载问题，网上也有相关解决方法。我这里就不阐述了（我都不用cnpm了，就不关心了！！！😮‍💨）</p><p>但是如果实在想安装也可以， CMD 中执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否安装成功</span></span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><h4 id="初步搭建博客">初步搭建博客</h4><p>安装并配置好 Node.js 环境后，我们就可以正式开始搭建个人博客了</p><p>用 Hexo 框架搭建博客很简单，只需几行命令就行</p><p>CMD执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo客户端，用于执行hexo的相关命令</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看hexo的版本</span></span><br><span class="line">hexo -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化构建博客 my_blog是我自己的博客目录</span></span><br><span class="line">hexo init my_blog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启博客</span></span><br><span class="line">hexo server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启博客也可以使用</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>安装hexo-cli</p></blockquote><p>hexo-cli 是操作 Hexo 的 “命令行工具”，安装后就能在 CMD 中直接执行 hexo 相关命令，比如 hexo -v、hexo init 等。如果没装，CMD 会提示 “不是内部或外部命令”​😭​。我们要想方便的构建Hexo个人博客，那就必须先安装hexo-cli。</p><p>CMD执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo客户端，用于执行hexo的相关命令</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看hexo的版本</span></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>下图表示已经安装成功</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106134353633.png" alt="image-20251106134352573"></p><blockquote><p>hexo初始化博客项目</p></blockquote><p>我们需要先创建一个博客项目，我在 D 盘的指定目录中操作</p><p>CMD执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化构建博客 my_blog是我自己的博客目录</span></span><br><span class="line">hexo init my_blog</span><br></pre></td></tr></table></figure><p>如果你执行的结果如下图，那么恭喜你😄，已经成功了，接下来可以直接执行启动命令。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106145104038.png" alt="image-20251105213936861"></p><p>但如果出现下面这种情况，就需要再处理一下。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106142212288.png" alt="image-20251106140335179"></p><p>上图的命令输出显示，连接 GitHub 超时（Timed out），最后提示 “Failed to install dependencies”。这是否意味着执行失败呢？其实不然，进入指定目录后会发现 my_blog 目录已经创建成功，说明项目已经拉取下来了。进入 my_blog 目录，也能看到 Hexo 的代码文件。这是怎么回事呢？</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106135033120.png" alt="image-20251105213846104"></p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106140430845.png" alt="image-20251106140429212"></p><p>这里必须要说明一下hexo init的这个命令的执行流程，我们从报文中可以看出流程如下：</p><ol><li>创建目录（我这里是 my_blog）</li><li>从 GitHub 克隆 hexo-starter 项目，拉取源码</li><li>执行 npm install 安装 Hexo 相关依赖</li><li>最后提示可以启动 hexo</li></ol><p>从输出来看，GitHub 连接超时但项目还是克隆下来了（我猜测可能是通过镜像拉取的，所以只是 warn 级别报错），但后续 npm install 安装依赖失败了。不过这不是大问题，自己重新执行 npm install 就行，命令也提示了可以手动执行 “npm install”。</p><p>为什么同样的命令会出现两种不同的结果呢？我推测是网络问题。我在家执行时基本都成功，在公司或网络不稳定的地方就容易出现第二种情况。我已经试过很多次了，有时候成功，有时候失败，真的很看脸​😭​。但如果你能正常访问GitHub，那么基本上是没问题的。就算出现第二种情况，也无非是多执行一次npm install。</p><blockquote><p>启动博客项目</p></blockquote><p>初始化完成后，我们就可以启动博客了</p><p>CMD执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启博客</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106135008768.png" alt="image-20251105214659411"></p><p>在浏览器中输入本地服务地址<a href="http://localhost:4000/%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%B0%B1%E8%AF%B4%E6%98%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%E4%BA%86%E3%80%82">http://localhost:4000/，如果看到如下页面，就说明个人博客初步搭建完成了。</a></p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20251105215109993.png" alt="image-20251105215109993"></p><h4 id="写一篇测试文章">写一篇测试文章</h4><p>进入 my_blog/source/_posts 目录，会发现已经有一篇 <a href="http://hello-world.md">hello-world.md</a> 的文章。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106151256904.png" alt="image-20251106151255834"></p><p>这篇文章就是我们在博客首页看到的第一篇文章</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106151611771.png" alt="image-20251106151610862"></p><p>我们打开这个markdown文件，发现这个md文件顶部有一个title: Hello World 内容。这种写法是hexo在渲染文章页时候用到写法，以后的内容我会专门开一期介绍这种写法。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106151824375.png" alt="image-20251106151822887"></p><p>我们可以仿照它写一篇，放到 my_blog/source/_posts 目录下</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106152443152.png" alt="image-20251106152441436"></p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106152537498.png" alt="image-20251106152536298"></p><p>在 CMD 中执行 hexo server 命令（也可以用 hexo s），就能看到测试文章已经发布到博客中了。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/20251106152836741.png" alt="image-20251106152835200"></p><p>到这里，我们已经初步搭建好了个人博客，并发布了一篇测试文章。</p><p>下一期我会介绍主题配置和 Hexo 相关命令，持续更新哦😄​💪​…</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper学习笔记</title>
      <link href="/posts/17764.html"/>
      <url>/posts/17764.html</url>
      
        <content type="html"><![CDATA[<h1>Zookeeper学习笔记</h1><h2 id="什么是Zookeeper">什么是Zookeeper</h2><p>ZooKeeper是一个<strong>分布式协调服务框架</strong>，为分布式系统提供一致性解决方案。 其一致性是通过<strong>Paxos算法</strong>的<strong>ZAB协议</strong>完成的。 非常优秀的一致性解决方案。</p><blockquote><p>数据存储</p><p>Watch监听机制</p></blockquote><h2 id="Zookeeper特点">Zookeeper特点</h2><ol><li>**顺序一致性：**从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li><li>**原子性：**事务请求在集群中得到的结果是一致的，即所有机器要么全部成功应用某个事务，要么全部未应用。</li><li><strong>单一系统映像：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性：</strong> 只要更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li><li><strong>实时性：</strong> 每个客户端的系统视图都是最新的。</li></ol><h2 id="Zookeeper概念">Zookeeper概念</h2><h3 id="数据模型">数据模型</h3><p>ZooKeeper数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二进制序列。</p><p>每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。 每个数据节点在ZooKeeper中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都有一个唯一的路径标识。</p><blockquote><p><strong>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的每个节点的数据大小上限是 1M 。</strong></p></blockquote><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/znode-structure.png" alt=""></p><h3 id="znode-数据节点">znode(数据节点)</h3><blockquote><p><strong>znode</strong>是 ZooKeeper中数据的最小单元， 每个znode都由**stat(状态信息)**和 **data(节点存放的数据)**组成</p></blockquote><h4 id="znode的类型">znode的类型</h4><ol><li>**持久节点：**一旦创建就一直存在，直到将其删除。</li><li>**持久顺序节点：**一个父节点可以为其子节点 <strong>维护一个创建的先后顺序</strong> ，这个顺序体现在 <strong>节点名称</strong> 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。</li><li>**临时节点：**临时节点的生命周期是与 <strong>客户端会话</strong> 绑定的，<strong>会话消失则节点消失</strong> 。临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li><li>**临时顺序节点：**父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。</li></ol><h4 id="znode状态信息">znode状态信息</h4><p>我通过get命令来获取根目录下的节点的内容</p><ol><li><code>czxid</code>：<code>Created ZXID</code>，该数据节点被 <strong>创建</strong> 时的事务 ID。</li><li><code>mzxid</code>：<code>Modified ZXID</code>，节点 <strong>最后一次被更新时</strong> 的事务 ID。</li><li><code>ctime</code>：<code>Created Time</code>，该节点被创建的时间。</li><li><code>mtime</code>：<code>Modified Time</code>，该节点最后一次被修改的时间。</li><li><code>version</code>：节点的版本号。</li><li><code>cversion</code>：<strong>子节点</strong> 的版本号。</li><li><code>aversion</code>：节点的 <code>ACL</code> 版本号。</li><li><code>ephemeralOwner</code>：创建该节点的会话的 <code>sessionID</code> ，如果该节点为持久节点，该值为 0。</li><li><code>dataLength</code>：节点数据内容的长度。</li><li><code>numChildre</code>：该节点的子节点个数，如果为临时节点为 0。</li><li><code>pzxid</code>：该节点子节点列表最后一次被修改时的事务 ID，注意是子节点的 <strong>列表</strong> ，不是内容。</li></ol><h3 id="会话（session）">会话（session）</h3><blockquote><p>Zookeeper客户端和服务端是通过**<code>TCP</code> 长连接<strong>维持的会话机制，其实对于会话来说你可以理解为</strong>保持连接状态** 。</p></blockquote><h3 id="ACL-权限控制">ACL(权限控制)</h3><p><code>ACL</code> 为 <code>Access Control Lists</code> ，它是一种权限控制。在 <code>zookeeper</code> 中定义了 5 种权限，它们分别为：</p><ul><li><code>CREATE</code>：创建子节点的权限。</li><li><code>READ</code>：获取节点数据和子节点列表的权限。</li><li><code>WRITE</code>：更新节点数据的权限。</li><li><code>DELETE</code>：删除子节点的权限。</li><li><code>ADMIN</code>：设置节点 ACL 的权限。</li></ul><h3 id="Watcher控制">Watcher控制</h3><p>Watcher为事件监听器，是zk非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端<strong>注册</strong>指定的Watcher， 当服务端符合了 watcher 的某些事件或要求则会<strong>向客户端发送事件通知</strong> ，客户端收到通知后找到自己定义的 Watcher然后<strong>执行相应的回调方法</strong> 。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/ac87b7cff7b44c63997ff0f6a7b6d2eb~tplv-k3u1fbpfcp-zoom-1.jpg" alt=""></p><h2 id="应用场景">应用场景</h2><blockquote><p>用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p></blockquote><ol><li>**命名服务：**可以通过 ZooKeeper 的顺序节点生成全局唯一 ID。</li><li>**数据发布/订阅：**通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。</li><li>**分布式锁：**通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。</li><li><strong>选举Master：</strong> 利用临时节点、节点状态 和 watcher 来实现选主的功能</li><li><strong>负载均衡：</strong> 可以通过 Zookeeper 的 <strong>临时节点</strong> 实现负载均衡 。</li><li>**集群管理和注册中心：**通过 <strong>Watcher 机制</strong>和临时节点实现。</li></ol><blockquote><p>PS：这些功能的实现基本都得益于 ZooKeeper 可以<strong>保存数据</strong>的功能，但是 ZooKeeper 不适合保存大量数据，这一点需要注意。</p></blockquote><h2 id="Zookeeper集群">Zookeeper集群</h2><h3 id="Zookeeper架构">Zookeeper架构</h3><p>通常 3 台服务器就可以构成一个 ZooKeeper 集群了。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/zookeeper-cluster.png" alt=""></p><p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过**ZAB 协议（ZooKeeper Atomic Broadcast）**来保持数据的一致性。</p><h3 id="Zookeeper集群角色">Zookeeper集群角色</h3><p>在 ZooKeeper 中没有的**Master/Slave(主从模式)**概念，而是引入了 Leader、Follower 和 Observer 三种角色。</p><ol><li><strong>Leader(领导者)：<strong>集群中</strong>唯一的写请求处理者</strong>，能够发起投票（投票也是为了进行写请求）。</li><li>**Follower(跟随者)：**能够接收客户端的请求，如果是读请求则可以自己处理，<strong>如果是写请求则要转发给 Leader</strong> 。在选举过程中会参与投票，<strong>有选举权和被选举权</strong> 。</li><li>**Observer(观察者)：**就是没有选举权和被选举权的Follower 。</li></ol><blockquote><p>ZooKeeper集群通过选举产生一个Leader，该Leader同时提供读写服务。Follower和Observer仅提供读服务，其中Observer不参与选举和写操作的“过半写成功”策略，这使得Observer能够在不影响写性能的前提下提升集群的读性能。</p></blockquote><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/zookeeper-cluser-roles.png" alt=""></p><h3 id="Zookeeper集群Leader选举过程">Zookeeper集群Leader选举过程</h3><blockquote><p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p></blockquote><p>这个过程大致是这样的：</p><ol><li><strong>Leader election（选举阶段）</strong>：节点在一开始都处于选举阶段，只要有一个节点得到<strong>超半数节点的票数</strong>，它就可以当选准 leader。</li><li><strong>Discovery（发现阶段）</strong>：在这个阶段，followers跟准leader进行通信，同步followers最近接收的事务议。</li><li><strong>Synchronization（同步阶段）</strong>：同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后准 leader 才会成为真正的 leader。</li><li><strong>Broadcast（广播阶段）</strong>：到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><p>ZooKeeper 集群中的服务器状态有下面几种：</p><ul><li><strong>LOOKING</strong>：寻找 Leader。</li><li><strong>LEADING</strong>：Leader 状态，对应的节点为 Leader。</li><li><strong>FOLLOWING</strong>：Follower 状态，对应的节点为 Follower。</li><li><strong>OBSERVING</strong>：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举</li></ul><h3 id="Zookeeper集群为啥最好是奇数台">Zookeeper集群为啥最好是奇数台</h3><p>因为ZooKeeper服务器个数大于宕掉的个数的话整个 ZooKeeper才依然可用， 2n 和 2n-1 的容忍度是一样的，都是 n-1</p><h3 id="Zookeeper选举过半机制防止脑裂">Zookeeper选举过半机制防止脑裂</h3><p><strong>脑裂</strong>：对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。</p><p>ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。</p><h2 id="ZAB协议">ZAB协议</h2><h3 id="Zookeeper架构-v2">Zookeeper架构</h3><p>ZooKeeper在解决分布式数据一致性问题时并没有直接使用Paxos算法，而是专门定制了一致性协议叫做<strong>ZAB(ZooKeeper Atomic Broadcast 原子广播协议)</strong> ，该协议能够很好地支<strong>持崩溃恢复</strong>。</p><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/07bf6c1e10f84fc58a2453766ca6bd18~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><h3 id="ZAB中的三个角色">ZAB中的三个角色</h3><ol><li><strong>Leader(领导者)：<strong>集群中</strong>唯一的写请求处理者</strong>，能够发起投票（投票也是为了进行写请求）。</li><li>**Follower(跟随者)：**能够接收客户端的请求，如果是读请求则可以自己处理，<strong>如果是写请求则要转发给 Leader</strong> 。在选举过程中会参与投票，<strong>有选举权和被选举权</strong> 。</li><li>**Observer(观察者)：**就是没有选举权和被选举权的Follower 。</li></ol><h3 id="ZAB中的两种模式">ZAB中的两种模式</h3><blockquote><p>在 <code>ZAB</code> 协议中对 <code>zkServer</code>(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是 <strong>消息广播</strong> 和 <strong>崩溃恢复</strong> 。</p></blockquote><ul><li><strong>消息广播</strong>：<strong>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。</strong> 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</li><li><strong>崩溃恢复</strong>：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致</strong>。</li></ul><h2 id="Zookeeper实战">Zookeeper实战</h2><h3 id="基于Zookeeper实现分布式锁">基于Zookeeper实现分布式锁</h3><blockquote><p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。</p></blockquote><h4 id="Zookeeper实现分布式锁的原理">Zookeeper实现分布式锁的原理</h4><blockquote><p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p></blockquote><p>获取锁：</p><ol><li>首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li><li>假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li><li>如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li><li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li></ol><p>释放锁：</p><ol><li>成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li><li>成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li><li>我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。</li></ol><p><img src="https://dmblogbucket.oss-cn-hangzhou.aliyuncs.com/blog/distributed-lock-zookeeper.png" alt=""></p><p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。</p><p><code>Curator</code>主要实现了下面四种锁：</p><ul><li><code>InterProcessMutex</code>：分布式可重入排它锁</li><li><code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li><li><code>InterProcessReadWriteLock</code>：分布式读写锁</li><li><code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li></ul><p><strong>持续更新中…</strong></p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
